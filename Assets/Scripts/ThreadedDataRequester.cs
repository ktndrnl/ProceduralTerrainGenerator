// ThreadedDataRequester.cs
//
// Description:
// A thread management system for Unity that handles asynchronous data generation
// while maintaining thread safety with Unity's main thread. Specifically designed
// to handle terrain generation tasks without causing frame rate drops.
//
// Key Features:
// - Safe multi-threading support for Unity
// - Queue-based thread result handling
// - Automatic main thread callback execution
// - Singleton pattern for global access
// - Thread-safe data transfer

using System;
using System.Collections.Generic;
using System.Threading;
using UnityEngine;

/// <summary>
/// Manages threaded data generation requests while maintaining Unity thread safety.
/// Implements a singleton pattern for global access to thread management.
/// </summary>
public class ThreadedDataRequester : MonoBehaviour
{
	/// <summary>
	/// Singleton instance of the ThreadedDataRequester.
	/// </summary>
	private static ThreadedDataRequester instance;

	/// <summary>
	/// Thread-safe queue storing data and callbacks from completed thread operations.
	/// </summary>
	private Queue<ThreadInfo> dataQueue = new();

	/// <summary>
	/// Initializes the singleton instance on Awake.
	/// </summary>
	private void Awake()
	{
		instance = FindAnyObjectByType<ThreadedDataRequester>();
	}

	/// <summary>
	/// Processes queued thread results on the main thread during each Update cycle.
	/// Ensures Unity API calls occur on the main thread.
	/// </summary>
	private void Update()
	{
		if (dataQueue.Count > 0)
		{
			for (int i = 0; i < dataQueue.Count; i++)
			{
				ThreadInfo threadInfo = dataQueue.Dequeue();
				threadInfo.callback(threadInfo.parameter);
			}
		}
	}
	
	/// <summary>
	/// Initiates a new thread for data generation with callback handling.
	/// </summary>
	/// <param name="generateData">Function that generates data on a separate thread</param>
	/// <param name="callback">Callback to handle the generated data on the main thread</param>
	/// <example>
	/// <code>
	/// ThreadedDataRequester.RequestData(
	///     () => GenerateComplexData(),
	///     result => HandleResult(result)
	/// );
	/// </code>
	/// </example>
	public static void RequestData(Func<object> generateData, Action<object> callback) 
	{
    	ThreadStart threadStart = delegate 
		{
    		instance.DataThread(generateData, callback);
    	};

    	new Thread(threadStart).Start();
    }

	/// <summary>
	/// Thread worker method that generates data and safely queues it with its callback.
	/// </summary>
	/// <param name="generateData">Data generation function</param>
	/// <param name="callback">Callback to handle the generated data</param>
	private void DataThread(Func<object> generateData, Action<object> callback) 
	{
    	object data = generateData();
    	lock (dataQueue) 
		{
    		dataQueue.Enqueue(new ThreadInfo(callback, data));
    	}
    }

	/// <summary>
	/// Structure to hold thread result data and its corresponding callback.
	/// </summary>
	private readonly struct ThreadInfo
	{
		/// <summary>
		/// Callback to be executed on the main thread with the generated data.
		/// </summary>
		public readonly Action<object> callback;

		/// <summary>
		/// Data generated by the thread operation.
		/// </summary>
		public readonly object parameter;

		/// <summary>
		/// Initializes a new instance of ThreadInfo with callback and generated data.
		/// </summary>
		/// <param name="callback">Callback to handle the data</param>
		/// <param name="parameter">Generated data to be passed to callback</param>
		public ThreadInfo(Action<object> callback, object parameter)
		{
			this.callback = callback;
			this.parameter = parameter;
		}
	}
}
